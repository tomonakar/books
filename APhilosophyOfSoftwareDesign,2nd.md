# Philosophy of Software Design
<https://www.amazon.co.jp/dp/B09B8LFKQL/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1>
## 3章 コードが動作することは十分なことではない（戦術的プログラミングvs戦略的プログラミング）

- 戦術的プログラミング：とにかく機能開発を優先させるパターン
  - 大体のスタートアップがこのパターンでコードを書いてる
  - よくある技術的負債はこのパターンで生まれる
- 戦略的プログラミング：複雑性と向き合って設計の良し悪しを判別しながらコードを書くパターン
- 開発初期の10-20%が、戦術的プログラミングの方が早く製品が完成する
- 小さな複雑さが積み重なり6-18ヶ月の間に戦略的プログラミングの方が生産性が高まる
- コードベースが悪いと採用にも悪影響を及ぼし、結果的に組織がスケールしない
- 良い設計をするために、通常の開発時間の10-20%を複雑性の解消に目を向けるよう投資するマインドを持つべき

## 4章モジュールは深くあるべき

複雑性を管理するための最重要テクニックは、開発者が常に全体の複雑性の一部にしか直面しなくて済むようシステム設計すること
理想は、各モジュールが完全に独立していることだが、現実はそうはいかないので、モジュール間の依存を最小にすることを目標にするべき
つまり、他のモジュールについて知るべきことを最小限に押さえることを考えるべき
ここでは、インターフェースと実装を持つコードの単位をモジュールと呼ぶ
モジュールの使い方はインターフェースから得られる情報と、モジュールを利用するための前提条件や実行後の破壊的な挙動など、コメントから得られる情報がある（非公式な側面）
非公式な側面を表すコメントは正しいとは限らず、システムの複雑性を増す要因になる
抽象化は、ある実体を簡略化し、重要でない詳細を省略したもの
抽象化には2つの失敗がある

1. 本当に重要ではない細部を含んでしまうこと
2. 本当は重要な詳細が省かれてしまうこと
最良のモジュールは、強力な機能を持ちながらもシンプルなインターフェースを持つもの
Shallow Module（中身が薄いモジュール）はシステムの複雑性を増すだけなので避けるべき
例えばJava I/OクラスのデザインはShallow Module
一般的に深いクラスや関数は避けるべきと言われているが、浅いクラスや浅いメソッドの大量作成は複雑性を増す原因になっている
UnixのI/Oモジュールのように、インターフェースはシンプルで、実装は深いモジュールがもたらす利益は大きい
まとめ：一般的なユースケースに対してシンプルなインターフェースを持ちながらも、重要な機能を提供できるようにモジュールを深くするべき

# 5章 情報の隠蔽

DeepModuleを実現するために最も重要な技術の１つが情報の隠蔽
新しいモジュールを設計する際には、そのモジュールでどんな情報を隠せるかをよく考える
多くの情報を隠せれば、インターフェースが自ずとシンプルになり、結果的にモジュールは深くなる
逆に、情報漏洩（1つの知識が複数のファイルで共有されている状態）に注意する（情報漏洩への感度を高くすることが設計者には必要）
時間的分解を行なって設計すると、情報漏洩が発生しやすくなるので、実行時の操作順に影響されないよう設計する
時間軸ではなく、アプリケーションのタスクを実行するために必要な知識を断片化し、それらの知識の断片のうちの1つまたはいくつかをカプセル化するように各モジュールを設計する（実行順はいずれどこかで表現することになる）
…この作者は今の所、とにかくモジュールが浅くなることへの警鐘を鳴らし続けてるな

# 6 汎用モジュールは難しい

- 特殊なケースや目的のコードは複雑性を増す大きな要因になるので、減らす努力をする（設計次第で大幅に減らせる）
-ユースケースに特化したクラスではなく、機能・コトを汎用的に扱える深いクラスを作って、シンプルなインターフェースで提供する
誰がいつ何を知る必要があるのかに留意して設計すると不要な知識を隠蔽できる
メソッド数を少なくすることは一見APIをシンプルにしているようだが、引数が追加されていると、単純化していることにはならない
ifのネストが多く発生するようなエッジケースは、実装方法次第ではチェックしなくても問題ない場合がある。エッジケースを削除しても問題がなくなる実装をきちんと考える
特殊なケースや目的のコードは複雑性を増す大きな要因になるので、減らす努力をする（設計次第で大幅に減らせる）
ユースケースに特化したクラスではなく、機能・コトを汎用的に扱える深いクラスを作って、シンプルなインターフェースで提供する
誰がいつ何を知る必要があるのかに留意して設計すると不要な知識を隠蔽できる
メソッド数を少なくすることは一見APIをシンプルにしているようだが、引数が追加されていると、単純化していることにはならない
ifのネストが多く発生するようなエッジケースは、実装方法次第ではチェックしなくても問題ない場合がある。エッジケースを削除しても問題がなくなる実装をきちんと考える

# 7 異なる層、異なる抽象化

```
システムの基盤となるインターフェースやクラスなどは開発者がそれを学習する必要が生じるため、複雑さが増す
上記の部品は、システム全体の複雑性の解消に具体的に貢献しなければ、デメリットにしかならない
パススルーは基本的にデメリットにしかならいので、使うなよ
とはいえ、現実には使わざるを得ない場面が発生するが、そういう時はcotext objectを使うことをお勧めする（ただし、これもデメリットがあり、最適解ではない）
```

# 9. better together or better apart

```
ボブおじさんはコードの長さを指標に分割を提唱してたけど、複雑性と責務を基準に分割すべき
シンプルなインターフェースとセットであれば深いモジュールは悪じゃなくて、むしろ推奨すべき
分割の指標
より綺麗な抽象化をもたらすサブモジュール分割（利用者はサブモジュールを知る必要がない）
責務を分離しインターフェースを分割できる時
```
