# Structural Patterns

## Compositeデザインパターン

Compositeデザインパターンは、継承（is a relationship）よりも構成(has a relationshipと定義される）を重視するデザイン。ここでは、has aアプローチによるオブジェクト構造の作り方を学ぶ。Goは性質上、純粋なCompositeプログラミング言語なので、このパターンを多用する。

### Description

Compositeデザインパターンでは、オブジェクトの階層とツリーを作成する。オブジェクトは、その内部に独自のフィールドやメソッドを持つ異なるオブジェクトを持つ。この方法は非常に強力で、継承や多重継承の多くの問題を解決することができる。

### 目的

コンポジションの目的は、このような多重継承による階層地獄を避けること。アプリケーションが複雑になるに従って、多重継承は可読性を著しく下げる。

Goでは、直接合成と埋め込み合成という2種類の合成を使うことができる。まず、直接合成を使って多重継承の問題を解決する。直接合成とは、必要なものをすべて構造体の中のフィールドとして持つこと。

### BinaryTree Compositions

Compositeパターンのもう一つの非常に一般的なアプローチは、Binary Tree構造を扱う場合が考えられる。Binary Treeでは、それ自体のインスタンスをフィールドに格納する必要がある。

## Adapter pattern

現実世界のアダプタと同じイメージ。
アプリケーションのOpen/Close原則を維持するのに役立つパターン。

### Adapter patterの目的

互換性のない2つの部分のニーズを適合させるのに役立つ。互換性がないが一緒に動作しなくてはならないインターフェースはAdapter patternの良い候補（ファサードパターンを利用することもある）

## Bridge Pattern

Bridgeパターンは、Gang of Fourの原著にある少し不可解な定義を持つデザイン。これは、抽象化を実装から切り離し、両者が独立して変化できるようにするもの。この不可解な説明は、機能の最も基本的な形である、オブジェクトをそれが行うことから切り離すことさえ可能であることを意味している。

### 説明

Bridgeパターンは、デザインパターンの常として、物事をデカップリングしようとする。それは、抽象化（オブジェクト）と実装（オブジェクトが行うこと）を切り離すものである。こうすることで、オブジェクトが何をするのかを好きなだけ変更することができる。また、同じ実装を再利用しながら、抽象化されたオブジェクトを変更することも可能である。

### Bridgeパターンの目的

Bridgeパターンの目的は、頻繁に変更される構造体に柔軟性を持たせることである。メソッドの入出力を把握し、純粋な関数型実装（副作用のない同じ入力に対して同じ出力をする）を作ることで、あまり深く知らなくてもコードを変更することができる。

## Proxyパターン

Proxyパターンは通常、オブジェクトをラップして、その特徴を隠します。例えば、リモートオブジェクトであること（リモートProxy）、非常に大きな画像やテラバイト級のデータベースのダンプのような非常に重いオブジェクト（仮想Proxy）、アクセスが制限されたオブジェクト（保護Proxy）などが挙げられます。

### Proxyパターンの目的

- 機能を隠したり、制限したりできるように、プロキシの後ろにオブジェクトを隠蔽する
- 作業が簡単で、簡単に変更できる新しい抽象化レイヤーを提供する。

### 例

この例では、データベースにアクセスする前にオブジェクトをキャッシュする Remote proxy を作成することにします。多くのユーザーを抱えるデータベースがあるとします。しかし、あるユーザーに関する情報が必要なときに毎回データベースにアクセスするのではなく、Proxy パターンでユーザーを FIFO (First In First Out) スタックするとします (キャッシュを空にする必要があるときに、最初に入ったオブジェクトを削除する)

## Decorator pattern

デコレータパターンは既存機能に変更を与えずに機能を追加する強力なパターン。
Proxyパターンとの違いは、Decoratorパターンでは、実行時に型に装飾を施す。つまり、装飾はあってもなくてもよく、また、1つまたは複数のオブジェクトで構成されていてもよいということだ。Proxyパターンも同じように型をラップするが、これはコンパイル時に行う。

この点で、Proxyは柔軟性に欠けると思われるかもしれない。しかし、Proxyパターンを使えばコンパイル時に回避できるエラーが Decoratorパターンの場合には、実行時に発生する可能性があるため、デコレータの方が弱いとも言える。

Decoratorは、Webサーバーのように、実行時にオブジェクトに機能を追加したい場合によく使われるものだということだけは覚えておくべき。トレードオフがあるので適切に使い分けができると良い。

## Flyweight pattern

Flyweightは、重いオブジェクトの状態を、ある種のインスタンス間で共有するためのパターン。例えば、基本的に同じ型のオブジェクトを大量に作成し、保存しなければならないとする。そうすると、すぐにメモリ不足に陥ってしまう。この問題は、Factoryパターンの助けを借りて、flyweightパターンで簡単に解決することができる。前回見たように、ファクトリーは通常オブジェクトの生成をカプセル化する役割を担っている。

### Flyweight patternの目的

フライウェイトパターンのおかげで、オブジェクトのすべての可能な状態を単一の共通オブジェクトで共有することができ、その結果、すでに作成されたオブジェクトへのポインタを使用することでオブジェクトの作成を最小限にすることができる。


