# Behavioral Patterns

 Behavioral patternsは、構造体を定義したり、オブジェクトをカプセル化したりするのではなく、振る舞いを扱うことになる。

ヘイビアパターンで何を扱うのか？例えば、Strategyパターンではアルゴリズムを、Commandパターンでは実行を、それぞれカプセル化する。

正しい振る舞いの設計は、オブジェクトの生成と構造の扱い方を知った後の最後のステップである。なぜなら、良いソフトウェア設計をすれば、アルゴリズムを改善したり、エラーを修正したりすることが容易になるからである。

## Strategy pattern

### Description

Strategyパターンは、ある特定の機能を実現するために、異なるアルゴリズムを使用する。これらのアルゴリズムはインターフェースの後ろに隠されており、当然、交換可能となる。すべてのアルゴリズムは、同じ機能を異なる方法で実現する。例えば、Sort インターフェースといくつかのソートアルゴリズムがあるとする。結果は同じで、あるリストがソートるが、アルゴリズムは、クイックショートやマージショートなどを使用することが可能になる。

前の章でStrategyパターンを使った。Strategyパターンを多用したのは、io.Writerインターフェイスである。io.Writer インターフェースは書き込むためのストラテジーを定義するもので、その機能は常に同じとなる。標準出力に書くことも、ファイルに書くことも、ユーザー定義型に書くこともできるが、最後にやることは同じ、「書く」ことです。書き込むための戦略を変えるだけである（この場合は書き込む場所を変えている）。

## Chain of responsibility pattern

- このパターンは、責任の連鎖（Chain of Responsibility）と呼ばれる
- チェーンで接続された構造で構成され、各リンクは単一責任の原則に従う

### 単一責任

- 型、関数、メソッド、または類似の抽象化は、単一の責任のみを持ち、そのことだけに専念する
- この原則に従えば、構造体、スライス、マップなどに対して、それぞれ1つのことを実現する関数を多数適用することができる
- これらの抽象化を論理的に適用していくと、例えば、ロギングチェーンのように、順番に実行されるように連鎖させることができる
  - ロギングチェーンとは、あるプログラムの出力を複数のio.Writerインターフェイスにログ出力する型の集合のこと
  - コンソールにログを記録するタイプ、ファイルにログを記録するタイプ、リモートサーバーにログを記録するタイプなどが考えられる
  - ロギングを行うたびに3つの呼び出しを行うこともできるが、1つだけ行って連鎖反応を引き起こす方がよりエレガント
Chain of responsibilityパターンの目的

## Command pattern

- コマンドパターンは、ストラテジーパターンに似ているが、着目している内容が異なる
- ストラテジーパターンはアルゴリズムに着目しているが、コマンドパターンは命令の呼び出しに着目している
- コマンドパターンは、命令をコマンドオブジェクトにして、それらを複数組み合わせて使えるようにするパターンである

## Template pattern

- 処理の共通部分を抽象化して抽出し、固有の処理を利用者に委ねるパターン

## Memento pattern

- Mementoの言葉の意味は、`記念品` `形見` `思い出の種
- このパターンはカプセル化の破壊を招くことなく、インスタンスの状態の保存・復元を行う方法を提供する
- 例えば、テキストエディタのアンドゥ機能を提供するような場合に利用される

### Mementoパターンの役割

- Originator(作成者):
  - 自分の状態を保存したMementoを作成する
  - 要求された状態に戻す
  - 自分自身の状態をMementoに保存する
- Memento
  - Originatorの内部情報を保存する
- Caretaker
  - Originatorの状態を保存したい場合、またはある時点に戻したい場合は、Originatorに指示を出す
  - Mementoを保持するタイミング・戻すタイミングを保持する役割を持つ
  - Mementoの履歴も保持する

## Interpreterパターン

何らかの文法規則を持ったプログラムを解析し、その結果得られた手順・命令に基づいて処理を実行するパターン

### Interpreterパターンの役割

1. AbstractExpression(抽象的な表現)
「TerminalExpression」・「NonTerminalExpression」に共通のインタフェースを定義します。
2. TerminalExpression(終端となる表現)
終端を表現するクラスです。階層関係の末端(構造木の葉)を表します。
3. NonTerminalExpression(非終端となる表現)
非終端を表現するクラスです。階層関係のノード(構造木の節)を表します。
4. Context(文脈・状況判断)
「Expression」(インタプリタ)が構文解析を行うための情報を提供します。
5. Client(利用者)
「Interpreter」パターンを適用したクラスを利用し処理します。

## Visitorパターン

Visitorパターンでは、オブジェクトの型のロジックの一部を、オブジェクトを訪問して操作を行うビジターと呼ばれる外部型に委譲する。

### Description

Visitorデザインパターンでは、特定のオブジェクトを操作するために必要なロジックをオブジェクト自体の外側に分離する。そのため、特定の型に対して何らかの処理を行う多くの異なるビジターを持つことができる。

例えば、コンソールに書き込むログライターがあるとする。このロガーを「訪問可能」にして、各ログに任意のテキストを前置きできるようにすることができる。オブジェクトに格納されたフィールドに、日付、時刻、ホスト名を前置するVisitorパターンを書くことができる。

### 目的

Behavioralデザインパターンでは、主にアルゴリズムを扱う。Visitorパターンも例外ではなく、私たちが達成しようとしている目的は、以下の通りです。

- ある型のアルゴリズムと、他の型の中の実装を分離する
- オブジェクトの構造を変更することなく、新しい機能を追加できるように、ロジックをほとんど、あるいはまったく使用せずに、ある型の柔軟性を向上させる
- 型のオープン/クローズの原則を破るような構造や振る舞いを修正する

open/closed principle・・・「エンティティは、拡張に対してはオープンであるが、変更に対してはクローズであるべきである」というも。この単純な状態は、より保守性の高い、エラーの起こりにくいソフトウェアを構築するための多くの意味を持っている。また、Visitorパターンは、よく変更されるアルゴリズムを、「安定」であることが必要な型から、元の型に影響を与えずに頻繁に変更できる外部の型に委譲するのに役立つ。

## Stateパターン

Stateパターンは、FSM(Finite State Machine: 有機状態マシーン) に直接関係する。
FSMとは、簡単に言うと1つ以上の状態を持ち、その間を移動して何らかの動作を実行するもの。
ここでは、StateパターンがFSMの定義にどのように役立っているか見ていく。

### 説明

電灯のスイッチはFSMの一般的な例。スイッチにはオンとオフの2つの状態がある。一方の状態から他方の状態に移行することができ、またその逆も可能である。

Stateパターンも同様に動作する。
Stateインターフェースと実現したい各状態の実装がある。
また、状態間の相互作用を保持するコンテキストも存在する。

FSMでは、ステート間でスコープを分割することで、複雑な振る舞いを実現することができる。
このよういんして、あらゆる種類の入力に基づく実行のパイプラインをモデル化したり、特定のイベントに特定の方法で応答するイベント駆動型のソフトウェアを作成することができる

### 目的

- 内部が変化したときに自身の振る舞いを変化させる方を持つこと
- 複雑なグラフやパイプラインをモデル化し、状態を追加したり出力系ろを変更するこで簡単にアップグレードできる
